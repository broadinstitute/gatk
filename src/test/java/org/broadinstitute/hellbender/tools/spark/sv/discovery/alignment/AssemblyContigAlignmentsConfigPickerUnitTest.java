package org.broadinstitute.hellbender.tools.spark.sv.discovery.alignment;

import com.google.common.collect.Lists;
import htsjdk.samtools.TextCigarCodec;
import org.apache.commons.collections4.IteratorUtils;
import org.broadinstitute.hellbender.GATKBaseTest;
import org.broadinstitute.hellbender.engine.spark.SparkContextFactory;
import org.broadinstitute.hellbender.tools.spark.sv.discovery.SVTestUtils;
import org.broadinstitute.hellbender.tools.spark.sv.discovery.inference.CpxSVInferenceTestUtils;
import org.broadinstitute.hellbender.utils.SimpleInterval;
import org.broadinstitute.hellbender.utils.read.CigarUtils;
import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;
import scala.Tuple2;

import java.util.*;
import java.util.stream.Collectors;

import static org.broadinstitute.hellbender.tools.spark.sv.StructuralVariationDiscoveryArgumentCollection.DiscoverVariantsFromContigsAlignmentsSparkArgumentCollection.GAPPED_ALIGNMENT_BREAK_DEFAULT_SENSITIVITY;
import static org.broadinstitute.hellbender.tools.spark.sv.discovery.SVTestUtils.fromPrimarySAMRecordString;
import static org.broadinstitute.hellbender.tools.spark.sv.discovery.SVTestUtils.makeDummySequence;
import static org.broadinstitute.hellbender.tools.spark.sv.discovery.SimpleSVDiscoveryTestDataProvider.b38_canonicalChromosomes;
import static org.broadinstitute.hellbender.tools.spark.sv.discovery.alignment.AssemblyContigAlignmentsConfigPicker.GoodAndBadMappings;
import static org.testng.Assert.assertEquals;
import static org.testng.Assert.assertTrue;

public class AssemblyContigAlignmentsConfigPickerUnitTest extends GATKBaseTest {

    @DataProvider(name = "contigAlignmentsHeuristicFilter")
    private Object[][] createTestData() {

        final List<Object[]> data = new ArrayList<>(20);

        AlignmentInterval intervalOne = new AlignmentInterval(new SimpleInterval("chr21", 1948156, 1948936),
                1, 787, TextCigarCodec.decode("257M4I182M2I342M361S"), true, 60, 8, 733, ContigAlignmentsModifier.AlnModType.NONE);
        AlignmentInterval intervalTwo = new AlignmentInterval(new SimpleInterval("chr21", 1948935, 1949190),
                893, 1148, TextCigarCodec.decode("892H256M"), true, 60, 3, 241, ContigAlignmentsModifier.AlnModType.NONE);
        AlignedContig contig = new AlignedContig("asm000063:tig00003", "CCACTGTGCCCGGCCAAGGGTCCCCGGTTCTGAAAGTGGAAGGGGTGCGGCTGCCTCAGGAGTCACCACGGCAACAAGAACCTGGACCTGAGCGCAGGTGGTCAGATTCTGGGGCCAGCAGCTTTTTGGTTTTTAGAGACGAGGTCTCACTCTGTTGCCCAGGCTGGAGTGCAGTGGTGCGATCACTGCACCCTGCAGCCTCGGCCTCCTGGTTTCAAGTGACCACAGATGCATGCAGCCATGCTTGGCATATATAAATATATATATATATATATATTTATGTGTATATTGGTAGAGACATGGTCTTGTTATATTGCCCAGGCTGATCGCAAACATCTGCTTAAGCGATCCTCCTGCGTTGGCTCTCCAAAGTATTGGGATTATAGGCATGAGCTACCATGGCCTGGCCTCCTTATTCTAGTCTTTTCTTTCCTTTCTTCTTGTTTTTTTTTTTTTTTTGGCAGGGTCTCACTCTGTCACCCAGGCTGCAGTGCAGTGGTGTGATCACAGCTCACTGCAGCCTCAACTTCCCAGGCTCAAGCGATCCTCCCGGCTCAGCATCCTGAGTAGCTGGGACTACAGATGCATGTCACCACGCCTGGCTAAATTTTCTTCTTTGTAGATATGGGGTCTCACCATGTAGTACTTTTCAATGTATTAAGCATCCTTATTTGATATTTGATGCCTGATAATACCCATGTCTGAACCATGCAAGATTGCTGCAATTCCTTCCTTCCTTCCCTCCCTCCTTCCCTTCCTTCCTTCCCTTTCCTTCCTTCCTCTTTCCCTCCCTTCTTTCCTTCCCTTTCCCTCCCTCCCTTCCTTCCTCTTTCCTTCCTTCCTTTCCCTCCCTTACTCCTTCCTTCCCTTCCCCTTCCTTCTTCCTTCTCTCCCTCCCTCCCTTCCCCTCCCTTACTCCCTTCCTTCCTCCTTCCCTCCCTCCTTTCCTTCATTCCCTTCCTTCCCCTTCCCCTTCCTTCCTTCTCTCCCTCCCTCCTTCCTTCCCTCCTTTCCTTCCTTCCTTCCTTTCCTTTCCCTCCTTCCTCCCTCCCTCCTTTCCTTCCTTCCTTTCCTTTCCTCCCTTCCCTCCCTCCCTCCCTCCCTTCCTTCCCCTCCCTCCCTCCTTTCCTTCTTTCGACAGAGTCTTG".getBytes(),
                Arrays.asList(intervalOne, intervalTwo));
        data.add(new Object[]{contig, Arrays.asList(intervalOne), Arrays.asList(intervalOne, intervalTwo), 1, 2});

        intervalOne = new AlignmentInterval(new SimpleInterval("chr2", 1422222, 1422435),
                1, 270,  TextCigarCodec.decode("75M56I139M"), false, 60, 56, 142, ContigAlignmentsModifier.AlnModType.NONE);
        intervalTwo = new AlignmentInterval(new SimpleInterval("chr2_KI270774v1_alt", 105288, 105555),
                1, 270,  TextCigarCodec.decode("114M1I27M1I127M"), false, 56, 13, 179, ContigAlignmentsModifier.AlnModType.NONE);
        contig = new AlignedContig("asm002608:tig00001", "ATGCTGGGGAATTTGTGTGCTCCTTGGGTGGGGACGAGCATGGAAGGCGCGTGGGACTGAAGCCTTGAAGACCCCGCAGGCGCCTCTCCTGGACAGACCTCGTGCAGGCGCCTCTCCTGGACCGACCTCGTGCAGGCGCCTCTCCTGGACAGACCTCGTGCAGGCGCCTCTCCTGGACCGACCTCGTGCAGGCGCCGCGCTGGACCGACCTCGTGCAGGCGCCGCGCTGGGCCATGGGGAGAGCGAGAGCCTGGTGTGCCCCTCAGGGAC".getBytes(),
                Arrays.asList(intervalOne, intervalTwo)/*, true*/);
        data.add(new Object[]{contig, Arrays.asList(intervalTwo), Arrays.asList(intervalOne), 3, 1});

        intervalOne = new AlignmentInterval(new SimpleInterval("chr21", 30374719, 30375721),
                1, 1002,  TextCigarCodec.decode("966M1D36M2362H"), true, 60, 6, 960, ContigAlignmentsModifier.AlnModType.NONE);
        intervalTwo = new AlignmentInterval(new SimpleInterval("chr21", 30375922, 30378473),
                826, 3364,  TextCigarCodec.decode("825S33M1D1047M7D553M5D906M"), true, 60, 24, 2423, ContigAlignmentsModifier.AlnModType.NONE);
        AlignmentInterval intervalThree = new AlignmentInterval(new SimpleInterval("chr1_KI270760v1_alt", 22529, 23531),
                1, 1002,  TextCigarCodec.decode("966M1D36M2362H"), true, 14, 3, 975, ContigAlignmentsModifier.AlnModType.NONE);
        AlignmentInterval intervalFour = new AlignmentInterval(new SimpleInterval("chr1_KI270760v1_alt", 23681, 26220),
                826, 3364,  TextCigarCodec.decode("825H33M1D2506M"), true, 60, 2, 2517, ContigAlignmentsModifier.AlnModType.NONE);
        contig = new AlignedContig("asm027070:tig00000", "GAGCCCATCTCCTTGACTGTGGCTCTGATGCTGCCTCCACACTGGGATCTCTCTGCTCTCTTCACCTCATACCTCCTTCCCCCCACCTCACCCCATCGCCCCCGTTCTTGATCCTGCAATTGTAGAAACAGAAAGTTGGCTGATTTCTTGGGCCCGCAAATTGCCCAACAGGGAGACTGGGTGGGCGGCCCCCGCTTCCACTCCATCGCCCACCCTGATGCATCGTCTGACACTTTCAATTTATTTTTCAATTCCTCTACCATCAGAAATGACGATTAGATTTCCAGCATAAATACCGCCTTACCAAACTGAATTAATCACGGCAAGGAGGGGCACACACAGGCTCCAGCAGCCTGGGCAGAACATCCCCAGCATTAACCCTTCCGTCCTCACCCAGGCCCCCACCAGCAGGACGGAGGCTCCAGGCCTCACAGAAGACGCCACTCAAAATATCACTGGGGTCACCTAATCCCATCCCCCTTACCCTTTGCAGCCTCCCTCCTGTGGGAGTTCCTAGGAAGTGTCTTGCCCAAAGCCATCCACTCCATCAGGGCAGAGTCAGAGACACTGGCCCCTCATCTCCAGCCCCATCAGGGAAGGAGGCTCCATCCACATCCAGGACAAGATGTGGGAGTATCCGGGGTTTGGCGTTGTCCAGGACACATACGGGACGGGACTCCTGCAGACCCGAGGGTGGGGGCACCCAGTGATCACAGGGCCTGAACTGAAAGGGGTCTTGGAGAGACCTGGAGGCAGGTTCCAACCCTTGCCCCACAAACAAGACCATCACCCCTCTTTGCTGAGACTGTTCATTGCTCAGTCCAACAACCACAGCTCAGGTTGACCTCCAGCCTCCCCACTTCTCCACCTCCCTGACTCCAACCACAGCTCAGGGTGACCTCCAGCCTCCCCACTTCTCCACCTCCCTGACTCCAACCACAGCTCAGGGTGACATCCAGCCTCCCCACTTCTCCACCTCCCTGACTCCAGCCACAGCTCAGGCTCCTTCCTATGAGACCCCCATGGCCTCTCACAGCCTCTCCACTTCTATGCCTGTTCTCACCCAATCCCCATCCCTCAGCAGTCATCACCTCAAAATGCAAACACTGTCCTATGGTTTCCTGGCTCAGAACCCATCGGGCCCTCCTCTGCTCTCAAATCAGGCCCCCACCCTTCAAGGCCATGAGGACTGGGCTGGCCTGGCCCCTACCGGTCAGTGCACTCCCCCATCCTGGCTGGGTTGTCTCCTCTTTCTCCTTCAAGTTTTTCTATTTAAAATTCCCCTCCTCAGAGAACCTTCTCTGGCCACCATCCCCCAATCTAAATTAGGTTCTCCCTCCTAAGGTTCTTTCTCAAATCCATTTCCTTTCCTTCTGAGCACTTAAGCGAGCGATAATTACACACTAACTTGTGTAATTTGTTTAATAGGATCTTTGGGACAGAGACTTTATCTGACTCGCTTGATGCTGCAGCTGCTAGAACCCAGACCGTAATGTAGTGGGAGCTCAGTGCAGACTTTTGAAGGAGTAAGTGAGTAAAAGAACAACAAGCCCCTCTTGGTGCCCACCAAGTGCCAAGCTGAGACTGGGCCCTGGAGCTGGAGTCAAGATGTGGACCTGGCCTTGGTGTGCTGGGCCCTAACAGATGAGTAGGAGTTTGCCGAGCACTGAAGGTGGGGTTGACATGACCAACTTCTGAGAGGCACTCTTTGCCTCTGGATGGCCCCTTCCCAGTCACCCCAAAAGGAAGCCCTTGCCCTTTCAAAAGTGGTGAATGTGGTGGTTCAGATCGGTAGGTGTTCCTATGAATAGGTGAGGGGCCAGGCTTCAGGTCAGTTGAACCTGGGTTTGAATCCTGATTTTGCTCTTGGTACTAGGGCAGGTCACTGAGACGCTCTGAGCCTCTCTGCTCCAGGATGAGGATCCCTTCATCCATGCTCACTCAAAGTCCTGCCCACCAGGATGGAGGCAGACAGGCTGCAATGCCCTCCCCTCTCAGTGGGGGAAAAATACCAGGTCAGGCAGCCAGCAGCCGAGAATGCCAGGCAGAGCAAAGGTGTCCTAAGGGATGGACAGAATAAGGGCTTGAGAGCCTAGCCAAGGGTGAGGCTAGGAGAGGCTTCCCGGAGGACGAGGCAAGTCAGAGCTCTTTGCCTCTTACTCCCATGACTGTGGGTGCCTTTCTCCTCCTCCTCTCATTCTCTCTCCTTTCCAGCTCCTGCTCTGCTCATTTCTTCACCTCAGTCTCTCTGCCCCGACAGGAGCCCTGAGGGACACAACCCCGTCCCGAGGAATGTATCTGCCCACTTCCAGCAGGTTCCTGGAGGCCCTCTAAATTCCCCTTCCCCCCAAAGTCATCTCCCAACACTGCTGCTCCCAGGGTGGGACGCCTGCTGCTGCACCTCCACACACGTGCACACACCCAGCCAGGTGCAGACAGCGTGGGCAGTGCAGAGGGGAGGGCTGGGGATTAAGGAGTTCGTGTTCTTGAGCAGCCTGGAAAGCAGCAGGGCTTCCACAGGAGCCGCCCCTGCCCTCACCCCTGCCCAGTAGGGTTAAGGGGCTGGCTTAGATGTCACCCCAAGCCAAGGCTGTCCTTCTCAGAGGCTCCTTCCCAGCTCCCCTGAGTGGGTCAGTCCCTTCCCCTCTCTGAGCCCCTCTTTCCTCTTCTGTAAAGCAGACTCAGTGATGTTGCTCAGAGGATTGAAGGACAAAGAAAAGCAACACAATGGACAGCAGGGATTTGCAAACAGCCGGGTGCTGTACCCAAGACAGGGTATTGCTGGTGATGTCTGATGGATGGGGAGTTGAAAGACTCAGCTGTCACTGGGCAGCTGGGTCTGGTTCCCCTGAGTCATTCGTAATTCACCAACCCAGTCTATAGAAGCTTATTAAGCACTTATTGTGTGCCATGCTCCATGCAAGGGCCAAAGACACCATGAGCAGAGCCAGACCCCACCCTCAGGTTCCCCCATGGGATGGGGTTAGCCAGATGACCTGAAGGCCTCTCCAGCCAGCTCAACCCCCTTAATCCAGAATTACTCCCTGTGCCAGGCTGACGGTGTGGCCAGAGAGGCCAGGGCCTGGGAGGGGGCCTGGCAGTGGGTGGTGGGAAGAGATGGAGTGGCTGTGTCAGGGGAAGGAGAGAGCAGGTTGTTCCTGTACAGGTTTCGCTCCTCGGATAGGGGGCTGCAATGACAGCTTCCAGGAAAGACCAGGCAAGTGCCTCACCCCATCCATTCTTGCTCACCCCTGCGGCCTCTTGGCCAATGGCTGCTGTGACCCTGTCCTCCTCTGGGAATCTGGTCTCGGGGAGGAGCCCTGGACCCTGACATTGACTAGAAACCTGACCCCATGTCTGAGCA".getBytes(),
                Arrays.asList(intervalOne, intervalTwo, intervalThree, intervalFour));
        data.add(new Object[]{contig, Arrays.asList(intervalOne, intervalFour), Arrays.asList(intervalThree, intervalFour), 2, 2});

        // this is a case where {intervalOne} is equally good with {intervalOne, intervalTwo}, but somehow the score for latter case is tiny bit better than the first
        intervalOne = new AlignmentInterval(new SimpleInterval("chr20", 60230348, 60231029),
                1, 682, TextCigarCodec.decode("682M"), false, 57, 68, 342, ContigAlignmentsModifier.AlnModType.NONE);
        intervalTwo = new AlignmentInterval(new SimpleInterval("chrUn_JTFH01001804v1_decoy", 3674, 4300),
                1, 627, TextCigarCodec.decode("627M55H"), true, 60, 1, 622, ContigAlignmentsModifier.AlnModType.NONE);
        contig = new AlignedContig("asm005003:tig00056", "AAAACTGCTCTATCAGAAGAAAGGTTAAGCTCTGAGAGTTGAACGCACACATCACAAAGTAGTTTCTAAGAATCATTCTGTCTGGTTTTCCTATGAAGATATTGCCTTTTCTACCATAGGCCTCAAACGGCACTAAATATCCTCTTTGAAATCCTTCAAAAAGAGACTCTCAAAACTTCTCTATCGAAAGGAAGGTTCAACACCGTGAGTTGAAAGCACACATCAGAAAGAAGTTTCTGAGAAGTATTCTGTCTAGTTTTATAGGAAGAAATCACGTTTCAAAAGAAGGCCACAAAGAGGTCCAAATATCCACTTGCAGATTCTACAAAAAGAGTGTTTCAAAACTGCTCTATCAAGAGAAATGTTCATCTCCGTGAGGTGAATGCAAATATTTCAATGTAGTTTCTGACAGTGCTTCTGTCTAGTTTTTATGTGAAGATATTTCCTTTTCTACCGTAGGCCTCAAAACACTCTCAATATACACTTGCAAATTCCACAAAAAGAGTGATTCAAAACTGCTCTATCAAAAGAAATTTTAAACGCTGTAAGCTGAATGCACACATCACAAAGTAGTTTCTGAGAATGATTCTGTCTAGTTTTTCTATGAAGATATTTCCTTTTCTACCATAGGCCTTGAAGCGCTCTAAATATCCACTTGGAAATTCTACAAAAAGAGTATTTC".getBytes(),
                Arrays.asList(intervalOne, intervalTwo)/*, true*/);
        data.add(new Object[]{contig, Arrays.asList(intervalOne, intervalTwo), Arrays.asList(intervalOne), 2, 1});

        return data.toArray(new Object[data.size()][]);
    }

    @Test(dataProvider = "contigAlignmentsHeuristicFilter", groups = "sv")
    public void testSuite(final AlignedContig contig,
                          final List<AlignmentInterval> configuration,
                          final List<AlignmentInterval> configurationEquallyGoodOrBetter,
                          final int expectedConfigurationCount,
                          final int expectedAICount) {

        final double scoreOne = AssemblyContigAlignmentsConfigPicker.computeScoreOfConfiguration(configuration, b38_canonicalChromosomes, 60);
        final double equallyGoodOrBetterScore = AssemblyContigAlignmentsConfigPicker.computeScoreOfConfiguration(configurationEquallyGoodOrBetter, b38_canonicalChromosomes, 60);
        assertTrue( scoreOne < equallyGoodOrBetterScore || scoreOne - equallyGoodOrBetterScore <= Math.ulp(equallyGoodOrBetterScore));

        assertEquals(AssemblyContigAlignmentsConfigPicker.pickBestConfigurations(contig, b38_canonicalChromosomes, 0.0).size(), expectedConfigurationCount);

        if (expectedConfigurationCount == 1) {

            final List<AlignmentInterval> alignments = AssemblyContigAlignmentsConfigPicker
                    .gatherBestConfigurationsForOneContig(
                            SparkContextFactory.getTestSparkContext().parallelize(Collections.singletonList(contig)),
                            b38_canonicalChromosomes, 0.0).values().collect().get(0).get(0).getGoodMappings();
            assertEquals(alignments.size(), expectedAICount,
                    alignments.stream().map(AlignmentInterval::toPackedString).collect(Collectors.toList()).toString());
        }
    }


    @DataProvider(name = "gapSplitFineTuning")
    private Object[][] createTestDataForGapSplit() {
        final List<Object[]> data = new ArrayList<>(20);

        final AlignmentInterval alignmentOne = new AlignmentInterval(new SimpleInterval("chrUn_JTFH01000492v1_decoy", 501, 1597),
                1, 1097, TextCigarCodec.decode("1097M6H"), true, 60, 1, 1092, ContigAlignmentsModifier.AlnModType.NONE);
        final AlignmentInterval alignmentTwo = new AlignmentInterval(new SimpleInterval("chr17", 26962248, 26962806),
                483, 1103, CigarUtils.invertCigar(TextCigarCodec.decode("121M1D142M1I165M62I130M482S")), false, 60, 97, 281, ContigAlignmentsModifier.AlnModType.NONE);

        final Iterable<AlignmentInterval> split = ContigAlignmentsModifier.splitGappedAlignment(alignmentTwo, GAPPED_ALIGNMENT_BREAK_DEFAULT_SENSITIVITY, 1103);
        data.add(new Object[]{
                new GoodAndBadMappings(Arrays.asList(alignmentOne, alignmentTwo), Collections.emptyList()),
                new GoodAndBadMappings(Collections.singletonList(alignmentOne), Lists.newArrayList(split))
        });

        return data.toArray(new Object[data.size()][]);
    }

    @Test(dataProvider = "gapSplitFineTuning", groups = "sv")
    public void testGapSplit(final GoodAndBadMappings inputConfiguration,
                             final GoodAndBadMappings expectedOutputConfiguration) {

        final GoodAndBadMappings configuration = AssemblyContigAlignmentsConfigPicker.splitGaps(inputConfiguration);
        Assert.assertEquals(configuration, expectedOutputConfiguration);
    }

    @DataProvider(name = "forFilterSecondaryConfigurationsByMappingQualityThreshold")
    private Object[][] forFilterSecondaryConfigurationsByMappingQualityThreshold() {

        final List<Object[]> data = new ArrayList<>(20);

        AlignmentInterval intervalOne = new AlignmentInterval(
                new SimpleInterval("chr21", 100001, 100100),
                1, 100, TextCigarCodec.decode("100M220S"),
                true, 60, 0, 100, ContigAlignmentsModifier.AlnModType.NONE);
        AlignmentInterval intervalTwo = new AlignmentInterval(
                new SimpleInterval("chr21", 100099, 100122),
                99, 122, TextCigarCodec.decode("98S24M78S"),
                true, 10, 3, 241, ContigAlignmentsModifier.AlnModType.NONE);
        AlignmentInterval intervalThree = new AlignmentInterval(
                new SimpleInterval("chr21", 100123, 100200),
                223, 300,  TextCigarCodec.decode("222S78M"),
                true, 60, 0, 78, ContigAlignmentsModifier.AlnModType.NONE);
        final GoodAndBadMappings rep1 =
                new GoodAndBadMappings(Arrays.asList(intervalOne, intervalThree),
                        Collections.singletonList(intervalThree));
        final GoodAndBadMappings rep2 =
                new GoodAndBadMappings(Arrays.asList(intervalOne, intervalTwo, intervalThree),
                        Collections.emptyList());

        data.add(new Object[]{Arrays.asList(rep1, rep2), 0, Arrays.asList(rep1, rep2)});

        data.add(new Object[]{Arrays.asList(rep1, rep2), 10, Collections.singletonList(rep1)});

        final AlignedContig alignedContig = SVTestUtils.fromPrimarySAMRecordString("asm031090:tig00000\t16\tchr5\t49659827\t60\t332S112M161S\t*\t0\t0\tCATTCCGTTCCGTTCCATTCCATTCCATTCCATTCTATTCGGGTTAATTCCATTCCATTCCATTCGATTGCAATCGAGTTGATTCCATTCCCTAACATTCCATTCCATTCCATTCCATTCCATTCCATTCCATTCCTTTCCATTCCATTACGGATGATTCCATTCCATTGCATTCCATTCCATTCCATTCCCCTGTACTCGGGTTGATTCCATTCCATTGCATTCCAATCCATGCCCTTCCACTCGTGTTGATTCCATTCTTTCCATTCCATTCAAGTTGAATCCATTCCATTGCAATCCATTCCATTCGATTCCATTCGATTGCACTCGGGTTGATTCCATTCCATTGCATTCCATTCCATTCCATTCCATTCCATTCCGTTCCATTCCTTTCCATTACATTCGGATTGATTCTATTCAATTCCCTTACACTCCATTACATTCCATTTCATTCCGGTAGTTTTCACTCCATTCCATTCCATTTCTCTCCATTCCATTGCACTCGGGTTGATTCCATTCCATTGCATTCCATTCCATTTGGGTAGTTTCCACTCCATTCCATTCCATTTCTCTCCATTCCATTGCACTCGGGTTGATTCCATTCC\t*\tSA:Z:chr22_KI270736v1_random,101512,+,455S56M94S,0,1;chr10,41903518,+,372S74M159S,48,7;chr20,31162579,+,37S59M509S,0,5;chr20,31188805,+,298S43M264S,0,2;chr4,49639434,+,331S37M237S,60,1;chrUn_KI270519v1,137524,+,101S37M467S,3,1;chrUn_KN707896v1_decoy,6014,-,81M15I253M5D189M67S,0,34;chrUn_KN707896v1_decoy,6436,-,517S88M,60,3;\tMD:Z:58A7C7G18T12C5\tRG:Z:GATKSVContigAlignments\tNM:i:5\tAS:i:87\tXS:i:55",
                true);
        final List<GoodAndBadMappings> goodAndBadMappings = AssemblyContigAlignmentsConfigPicker.pickBestConfigurations(alignedContig,
                new HashSet<>(Arrays.asList("chr4", "chr5", "chr10", "chr20", "")), 0.0);
        final List<AlignmentInterval> goodAfterTieBreak = SVTestUtils.fromPrimarySAMRecordString("asm031090:tig00000\t16\tchr5\t49659827\t60\t332S112M161S\t*\t0\t0\tCATTCCGTTCCGTTCCATTCCATTCCATTCCATTCTATTCGGGTTAATTCCATTCCATTCCATTCGATTGCAATCGAGTTGATTCCATTCCCTAACATTCCATTCCATTCCATTCCATTCCATTCCATTCCATTCCTTTCCATTCCATTACGGATGATTCCATTCCATTGCATTCCATTCCATTCCATTCCCCTGTACTCGGGTTGATTCCATTCCATTGCATTCCAATCCATGCCCTTCCACTCGTGTTGATTCCATTCTTTCCATTCCATTCAAGTTGAATCCATTCCATTGCAATCCATTCCATTCGATTCCATTCGATTGCACTCGGGTTGATTCCATTCCATTGCATTCCATTCCATTCCATTCCATTCCATTCCGTTCCATTCCTTTCCATTACATTCGGATTGATTCTATTCAATTCCCTTACACTCCATTACATTCCATTTCATTCCGGTAGTTTTCACTCCATTCCATTCCATTTCTCTCCATTCCATTGCACTCGGGTTGATTCCATTCCATTGCATTCCATTCCATTTGGGTAGTTTCCACTCCATTCCATTCCATTTCTCTCCATTCCATTGCACTCGGGTTGATTCCATTCC\t*\tSA:Z:chr10,41903518,+,372S74M159S,48,7;chr4,49639434,+,331S37M237S,60,1;chrUn_KI270519v1,137524,+,101S37M467S,3,1;chrUn_KN707896v1_decoy,6436,-,517S88M,60,3;\tMD:Z:58A7C7G18T12C5\tRG:Z:GATKSVContigAlignments\tNM:i:5\tAS:i:87\tXS:i:55",
                true).getAlignments();
        final ArrayList<AlignmentInterval> copy = new ArrayList<>(alignedContig.getAlignments());
        copy.removeAll(goodAfterTieBreak);
        data.add(new Object[]{goodAndBadMappings, 0, Collections.singletonList(new GoodAndBadMappings(goodAfterTieBreak, copy))});

        return data.toArray(new Object[data.size()][]);
    }

    @Test(groups = "sv", dataProvider = "forFilterSecondaryConfigurationsByMappingQualityThreshold")
    public void testFilterSecondaryConfigurationsByMappingQualityThreshold(final List<GoodAndBadMappings> representations,
                                                       final int threshold,
                                                       final List<GoodAndBadMappings> expectedResult) {

        Assert.assertEquals(AssemblyContigAlignmentsConfigPicker.filterSecondaryConfigurationsByMappingQualityThreshold(representations, threshold),
                            expectedResult);
    }

    @DataProvider(name = "forTestingNotDiscardForBadMQ")
    private Object[][] forTestingNotDiscardForBadMQ() {

        final List<Object[]> data = new ArrayList<>(20);

        final AlignedContig outForEmptyAlignments = new AlignedContig("unmapped", "AAAAAAAAAA".getBytes(), Collections.emptyList());
        data.add(new Object[]{outForEmptyAlignments, false});

        final AlignedContig outForSingleBadMapping = new AlignedContig("badMap", makeDummySequence(151, (byte)'T'),
                Collections.singletonList(new AlignmentInterval(new SimpleInterval("chr1", 1000000, 1000150),
                        1, 151, TextCigarCodec.decode("151M"), true, 5, 39, 100, ContigAlignmentsModifier.AlnModType.NONE)));
        data.add(new Object[]{outForSingleBadMapping, false});

        final AlignmentInterval intervalOne = new AlignmentInterval(
                new SimpleInterval("chr21", 100001, 100100),
                1, 100, TextCigarCodec.decode("100M220S"),
                true, 60, 0, 100, ContigAlignmentsModifier.AlnModType.NONE);
        final AlignmentInterval intervalTwo = new AlignmentInterval(
                new SimpleInterval("chr21", 100099, 100122),
                99, 122, TextCigarCodec.decode("98S24M78S"),
                true, 10, 3, 241, ContigAlignmentsModifier.AlnModType.NONE);
        final AlignedContig outForOnlyOneGaplessGoodMapping = new AlignedContig("lonelyGood", makeDummySequence(320, (byte)'C'),
                Arrays.asList(intervalOne, intervalTwo));
        data.add(new Object[]{outForOnlyOneGaplessGoodMapping, false});

        final AlignedContig stayForOneGappedGoodMapping =
                fromPrimarySAMRecordString("asm000576:tig00001\t16\tchr1\t30894493\t60\t106S126M67D873M\t*\t0\t0\tGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGTGAGTATGAGTGGGTGAGAGTGTGAGTGGGTGAGAGTGTGTGTGGATGAGTGTGTGTGGGTGAGAGTGTGTGGGTGTATGTGTGGGCTACGTGTGTGTGGGTGTGTGTGGATGAGTGTGAGTGTGGGTGAGAGTGTGTGGGTGTGTGTGGGGAGTGTGTGTGTGTATGTGTGAATGTGTGGGCGTACACAGGCATGCACATGCACACATCCAAGCACATTCAGGGGTATTTCTGGGCGTGTGTGTCTGTCTAGGTGCATCCATGTGTGTATGCCTAGGGCTGTCTCGAGTGGCTTAGATGCCTGTGTGGGTCTGAGTGTGTCCATGTTAGCGTGGAGGGCTGTGTCTCTGAGTGGTACCTGTGCACATGGCAGTGTATGTGTGTCCCTGTCTCTGTCTCTACACGTGTGCACAGGACAAGGGTATTTGCACAGGTCCATGTTCCTCCATTTGTAAGCATGCATCTGAGCCTCCCAAGGTAGAGAGCATCTCCCAACTTCCTTAATCCACAGTGTTGGGGGTAAGCCCCTGGAGCTGAGGCAGGGGGAGGGACAGCAGATGGGGGACTCCTGATCCCCCTGGCATAGGCTACAAACACTTTTTCCTACAAAGACACCAGGGCCCCATGCATCAGCACAGACACACAACAACATGCCATCACACATGTTGCAGGTACACGCAAACCCCTAACCCAAACTAACGTCCTAAACAGAAACATGGCCTTAGCTCCACGTGGAAAAAGGATTACCTGGCCTCACTTGCAGCCTTGCAGACCATCCCTCAAGACACAGCTGAGCTCCCTCTGGATCTGAGATTGTCCCCACAAGCCCCCCAGCTCCGCAGCTCACATGAGAATAGGATCCAGCCAGCCAGGGCTCAGCTCCCAGAGGCCATGTAGGGGCTTCAGCCCCGGGGAAGCTGTTCCACTTCTCACTGCTGAGTGACCCTCAACAGCCACACTTCATCTCTGGGTTCAGTCTCCTCATCTGAACAG\t*\tSA:Z:chr2,32916450,-,107M998S,0,2;\tMD:Z:46C79^GTGTGGGTGAGAGTGTGTGGGTGTGTGTGGGGTGTGTGTGGGTGAGTGTGTGTGGATGACTGTGAGT396C40T435\tRG:Z:GATKSVContigAlignments\tNM:i:70\tAS:i:901\tXS:i:0",
                        true);
        data.add(new Object[]{stayForOneGappedGoodMapping, true});

        final AlignedContig stayForOneGoodMapping =
                fromPrimarySAMRecordString("asm022620:tig00006\t0\tchr1\t176967755\t60\t1022M\t*\t0\t0\tCTGTTGCTAAGTAGTTTAGGTCAAGGAGACCTCCTGCTCTTGAGGGGCCTGAAAATTAAGAAAATCAACTCAAATTGGAAGGATGTAGAGGAGTGCAGCGTAGACCCCACCCTGATCACATTTAGAGGCAGGAGTGCAGTGTAGACCCCACCCTGATCACATTTAGAGGCAGGAGTGTAGTGTAGACCCCATCCTGATCACATTTAGAGGCAGGAGTGTAGTGTAGACCCCATCCTGATCACATTTAAAGGCAGCAGGGCACAGTGGTTTCAGGACATGGATTCTGGCGTTAGCCTGCCTATTTCAAATGCCAGCTTAGCCACCAATCACTGTGTGACTTTGGGCAAGTTCCTTCATCATTCTGTAACCCCATATCCTCATCTGTAAAATGAGGCAGATGGTAATAACTGTATTTATTTGACAAAGTTGTTATGAGGAGGAACTAGCTAATGTAATTAAAGTGCCTAGAACAGTGCGTGGCATTTAGTGAGTGCCACACATAGAATCATTTGTTAAATAAGTTAAATTGATCAATTACATGCATCAAATATAAATACTATAAGGAGTGTTTCCCAAATTTCAATAGAGGAAGATGTGTCTTGCCCTAAGGTGCAAATGCAATGCCAACGCCAGGCTTTAACTCAGATTATAGATGTCTTCACATAGGCTGGAGAGGAGGCAACATGAGTATGGAAAGGCCAAAGCCCCGACACCCCACCTCCCACCTCCCACTTCCCACCCAGTGGTCACTTCACTGGGCAACTCACTCTACAGCATTGACATTAAACACAAAGAGCAGGGAAGTGCATATTGTGAAATGGCAAGAGAAGTCAGCGAGTAGCAAAATTGCACCAGCAAAGGAATAAAGGGGAATTTACCTAATTTCTTCCCTCTAGTCCGGAATGATCTGTCAGAGAGATGAGAAATCTTACTTGATTTATTTAGCAAATATTTGTGGAGGCCTATTGTGTGTGAACTGTGATATTAGGCAACAGGAATTGGGATAAAGAGATTCCTGCCCT\t*\tMD:Z:287A734\tRG:Z:GATKSVContigAlignments\tNM:i:1\tAS:i:1017\tXS:i:165",
                        false);
        data.add(new Object[]{stayForOneGoodMapping, true});

        final AlignedContig stayForTwoGoodMappings =
                fromPrimarySAMRecordString("asm017085:tig00001\t0\tchr10\t91874806\t60\t142S150M\t*\t0\t0\tAAAAAAAAGAATCTCTGAGAAAATACACAGGAAACTGATAATCTGGTTGCTTCTATGAAGGAAACGGCATGGCAGGGGATGGGATGGAAGGGAGGCTTGCTTTTCACTCTATTGCCTTTTGAATTCTGTACTGTGTGCATTTCACAATGTTGTGCTTAGAATTATAGAAAAACAAAAGCACAGCTCTGAACATGGGTGTCCCAATGGCACCTCAGCCTTAACCAACTTCTGCCTCTATTGCAAGCTCTTAATTGGCCTCACCTCTCACTTTCCTCATACAATTGACATTCCA\t*\tSA:Z:chr10,91873437,+,145M147S,60,0;\tMD:Z:150\tRG:Z:GATKSVContigAlignments\tNM:i:0\tAS:i:150\tXS:i:19",
                        true);
        data.add(new Object[]{stayForTwoGoodMappings, true});

        return data.toArray(new Object[data.size()][]);
    }

    @Test(dataProvider = "forTestingNotDiscardForBadMQ", groups = "sv")
    public void testNotDiscardForBadMQ(final AlignedContig contig, final boolean shouldKeep) {
        Assert.assertEquals(AssemblyContigAlignmentsConfigPicker.notDiscardForBadMQ(contig), shouldKeep);
    }

    @DataProvider(name = "forTestSpecialChanelForSingleNonCanonicalMappings")
    private Object[][] forTestSpecialChanelForSingleNonCanonicalMappings() {
        final List<Object[]> data = new ArrayList<>(20);

        // note chromosome names is hacked to use test seq dict

        final AlignmentInterval altOne = SVTestUtils.fromSAMRecordString("asm000099:tig00029\t2064\tchr1_KI270762v1_alt\t207249\t2\t38H252M229H\t*\t0\t0\tGAGCATCTGACAGCCTGGAACAGCACCCATACGCCCAGATGAGCATCTGACAGCCTGAAACAGCACCCTGCACCCCCAGGTGTGCAACTGACAGCCTGGAACAGCACACACTCACCCAGGCCAGCATCTGATGGCCTGGAACGGCACCCACACCCCCAGGTAAGCATCCGACATCCTGAAACAGCTCCCACACCCCCAGGCGAGCATCTGACAGCCTGGAGCAGTGCCCACACCCCCAGGTGAGCATCTGAC\t*\tSA:Z:chr1,2655749,-,125S394M,1,42;chr1,2667827,-,66M453S,0,3;chr1,2761512,-,95S50M374S,0,3;chrUn_JTFH01001111v1_decoy,1,+,22S273M224S,46,12;chr1_KI270762v1_alt,207251,-,66M453S,0,2;\tMD:Z:57G11A2T13C20C12G0G19T19G30A7T7C15C0A4T21\tRG:Z:GATKSVContigAlignments\tNM:i:15\tAS:i:177\tXS:i:172", true);
        final AlignmentInterval altTwo = SVTestUtils.fromSAMRecordString("asm000099:tig00029\t2064\tchr1_KI270762v1_alt\t207251\t0\t66M453H\t*\t0\t0\tGCATCTGACAGCCTGCAACCGCACCCATACGCCCAGATGAGCATCTGACAGCCTGGAACAGCACCC\t*\tSA:Z:chr1,2655749,-,125S394M,1,42;chr1,2667827,-,66M453S,0,3;chr1,2761512,-,95S50M374S,0,3;chrUn_JTFH01001111v1_decoy,1,+,22S273M224S,46,12;chr1_KI270762v1_alt,207249,-,38S252M229S,2,15;\tMD:Z:15G3A46\tRG:Z:GATKSVContigAlignments\tNM:i:2\tAS:i:56\tXS:i:56", true);
        final AlignmentInterval canonicalOne = SVTestUtils.fromSAMRecordString("asm000099:tig00029\t16\tchr21\t2655749\t1\t125S394M\t*\t0\t0\tGCATCTGACAGCCTGCAACCGCACCCATACGCCCAGATGAGCATCTGACAGCCTGGAACAGCACCCATACGCCCAGATGAGCATCTGACAGCCTGAAACAGCACCCTGCACCCCCAGGTGTGCAACTGACAGCCTGGAACAGCACACACTCACCCAGGCCAGCATCTGATGGCCTGGAACGGCACCCACACCCCCAGGTAAGCATCCGACATCCTGAAACAGCTCCCACACCCCCAGGCGAGCATCTGACAGCCTGGAGCAGTGCCCACACCCCCAGGTGAGCATCTGACATCGTGGAGCAGCACCCACAGCCCAAGGTGAGCATCTGACAACCAGGAGCAGCACCCACACACCCAGGCGAGCATCAGAATGCACGGAGCATCACCCACACCCCCAGGCGAGCATCCGACAGCCTGGAGCAGCACCCACACCCCCAGGCGAGCATCTGACAGCCTGGAGCAGTGCCCACACCCCCAGGTGAGCATCTGACAGCGTGGAGCAGCACCCACAGCCCAAGGT\t*\tSA:Z:chr1,2667827,-,66M453S,0,3;chr1,2761512,-,95S50M374S,0,3;chrUn_JTFH01001111v1_decoy,1,+,22S273M224S,46,12;chr1_KI270762v1_alt,207249,-,38S252M229S,2,15;chr1_KI270762v1_alt,207251,-,66M453S,0,2;\tMD:Z:15G4C3A8T0G12T5G1A9A2A5G1A4G2G1G0T3G1G4G44A22G59C14T3C10G10T2C42T1C8T0G1T9C0A7A1A0G14G3C4A3A11C4\tRG:Z:GATKSVContigAlignments\tNM:i:42\tAS:i:184\tXS:i:177", true);
        final AlignmentInterval canonicalTwo = SVTestUtils.fromSAMRecordString("asm000099:tig00029\t2064\tchr21\t2667827\t0\t66M453H\t*\t0\t0\tGCATCTGACAGCCTGCAACCGCACCCATACGCCCAGATGAGCATCTGACAGCCTGGAACAGCACCC\t*\tSA:Z:chr1,2655749,-,125S394M,1,42;chr1,2761512,-,95S50M374S,0,3;chrUn_JTFH01001111v1_decoy,1,+,22S273M224S,46,12;chr1_KI270762v1_alt,207249,-,38S252M229S,2,15;chr1_KI270762v1_alt,207251,-,66M453S,0,2;\tMD:Z:10A4G3A46\tRG:Z:GATKSVContigAlignments\tNM:i:3\tAS:i:51\tXS:i:51", true);
        final AlignmentInterval canonicalThree = SVTestUtils.fromSAMRecordString("asm000099:tig00029\t2064\tchr21\t2761512\t0\t95H50M374H\t*\t0\t0\tAAACAGCACCCTGCACCCCCAGGTGTGCAACTGACAGCCTGGAACAGCAC\t*\tSA:Z:chr1,2655749,-,125S394M,1,42;chr1,2667827,-,66M453S,0,3;chrUn_JTFH01001111v1_decoy,1,+,22S273M224S,46,12;chr1_KI270762v1_alt,207249,-,38S252M229S,2,15;chr1_KI270762v1_alt,207251,-,66M453S,0,2;\tMD:Z:25A3T11A8\tRG:Z:GATKSVContigAlignments\tNM:i:3\tAS:i:35\tXS:i:35", true);

        data.add(new Object[]{Arrays.asList(canonicalOne, canonicalTwo, canonicalThree, altOne, altTwo), 184, null});

        final AlignmentInterval canonical = SVTestUtils.fromSAMRecordString("asm002362:tig00002\t16\tchr21\t1422222\t60\t75M56I139M\t*\t0\t0\tATGCTGGGGAATTTGTGTGCTCCTTGGGTGGGGACGAGCATGGAAGGCGCGTGGGACTGAAGCCTTGAAGACCCCGCAGGCGCCTCTCCTGGACAGACCTCGTGCAGGCGCCTCTCCTGGACCGACCTCGTGCAGGCGCCTCTCCTGGACAGACCTCGTGCAGGCGCCTCTCCTGGACCGACCTCGTGCAGGCGCCGCGCTGGACCGACCTCGTGCAGGCGCCGCGCTGGGCCATGGGGAGAGCGAGAGCCTGGTGTGCCCCTCAGGGAC\t*\tSA:Z:chr2_KI270774v1_alt,105288,-,114M1I27M1I127M,56,13;\tMD:Z:214\tRG:Z:GATKSVContigAlignments\tNM:i:56\tAS:i:142\tXS:i:0\n", true);
        final AlignmentInterval nonCanonical = SVTestUtils.fromSAMRecordString("asm002362:tig00002\t2064\tchr2_KI270774v1_alt\t105288\t56\t114M1I27M1I127M\t*\t0\t0\tATGCTGGGGAATTTGTGTGCTCCTTGGGTGGGGACGAGCATGGAAGGCGCGTGGGACTGAAGCCTTGAAGACCCCGCAGGCGCCTCTCCTGGACAGACCTCGTGCAGGCGCCTCTCCTGGACCGACCTCGTGCAGGCGCCTCTCCTGGACAGACCTCGTGCAGGCGCCTCTCCTGGACCGACCTCGTGCAGGCGCCGCGCTGGACCGACCTCGTGCAGGCGCCGCGCTGGGCCATGGGGAGAGCGAGAGCCTGGTGTGCCCCTCAGGGAC\t*\tSA:Z:chr2,1422222,-,75M56I139M,60,56;\tMD:Z:94C17G1G6T13T3G1G34A3T9T68T8\tRG:Z:GATKSVContigAlignments\tNM:i:13\tAS:i:179\tXS:i:142", true);
        data.add(new Object[]{Arrays.asList(canonical, nonCanonical), 142, nonCanonical});

        final AlignmentInterval one = SVTestUtils.fromSAMRecordString("asm008084:tig00048\t16\tchr20\t188506254\t60\t182S253M\t*\t0\t0\tGTTGTAGATTAACTGATGTCCAAATAGGAGGAAATAGCATAAGATCATGGAAGAGAGAGGGCAGTAGATTACCTGATGTCGAAATAGCAGGTAAGAGCATACTGTCCTGGAAGAGAGGGCTGTAGATTACCTGATGTCCAAATAGTAGGTAATATCGTAATGTGCTGGAAGAGAGAGGGCTTTAGATTACCTGATGTCCAAATAGGAGGAAATAGCATAAGGTCCTGGAGGACAAAGGTGTTGTAGATTACATGATGTCCAAATAGGACGTAATAGCATAAGGTCCTGGAAGACAAAGGTGTTGTAGATTACCTGATGTCCAAATAGGAGGTAATAGAATACGGTCCTGGAAGAGAGGGCTGTAAATTACCCGATGTCAAAATAGGAGGTAATAGAATAAGGTCCTGGAGGAGAGGGCTGTAGATTACCTGATGT\t*\tSA:Z:chr4,188507694,-,229M206S,60,22;chr4_KI270789v1_alt,167965,-,122M60I253M,60,62;\tMD:Z:16T99T42A29T6C19C36\tRG:Z:GATKSVContigAlignments\tNM:i:6\tAS:i:223\tXS:i:157", true);
        final AlignmentInterval two = SVTestUtils.fromSAMRecordString("asm008084:tig00048\t2064\tchr20\t188507694\t60\t229M206H\t*\t0\t0\tGTTGTAGATTAACTGATGTCCAAATAGGAGGAAATAGCATAAGATCATGGAAGAGAGAGGGCAGTAGATTACCTGATGTCGAAATAGCAGGTAAGAGCATACTGTCCTGGAAGAGAGGGCTGTAGATTACCTGATGTCCAAATAGTAGGTAATATCGTAATGTGCTGGAAGAGAGAGGGCTTTAGATTACCTGATGTCCAAATAGGAGGAAATAGCATAAGGTCCTGGA\t*\tSA:Z:chr4,188506254,-,182S253M,60,6;chr4_KI270789v1_alt,167965,-,122M60I253M,60,62;\tMD:Z:11C5A4G24C32C13T6A31G11G8G0G0A3G2C0A1T1G12G19G7T3C0A14\tRG:Z:GATKSVContigAlignments\tNM:i:22\tAS:i:119\tXS:i:58", true);
        final AlignmentInterval three = SVTestUtils.fromSAMRecordString("asm008084:tig00048\t2064\tchr4_KI270789v1_alt\t167965\t60\t122M60I253M\t*\t0\t0\tGTTGTAGATTAACTGATGTCCAAATAGGAGGAAATAGCATAAGATCATGGAAGAGAGAGGGCAGTAGATTACCTGATGTCGAAATAGCAGGTAAGAGCATACTGTCCTGGAAGAGAGGGCTGTAGATTACCTGATGTCCAAATAGTAGGTAATATCGTAATGTGCTGGAAGAGAGAGGGCTTTAGATTACCTGATGTCCAAATAGGAGGAAATAGCATAAGGTCCTGGAGGACAAAGGTGTTGTAGATTACATGATGTCCAAATAGGACGTAATAGCATAAGGTCCTGGAAGACAAAGGTGTTGTAGATTACCTGATGTCCAAATAGGAGGTAATAGAATACGGTCCTGGAAGAGAGGGCTGTAAATTACCCGATGTCAAAATAGGAGGTAATAGAATAAGGTCCTGGAGGAGAGGGCTGTAGATTACCTGATGT\t*\tSA:Z:chr4,188506254,-,182S253M,60,6;chr4,188507694,-,229M206S,60,22;\tMD:Z:311T6C56\tRG:Z:GATKSVContigAlignments\tNM:i:62\tAS:i:289\tXS:i:223", true);
        data.add(new Object[]{Arrays.asList(one, two, three), 223, three});

        final AlignmentInterval normalOne = SVTestUtils.fromSAMRecordString("asm000012:tig00003\t2048\tchr1\t933803\t60\t317M302H\t*\t0\t0\tTCCTGGAAGGTTTAGAGCCCAGCCTGGGAGTCTTTGGTGCTGAAACGGATCTGCTTAGGGGCAGCCTTGGATTAGCCCAGCTCCAGCCAGCCCAGGTCAGGGGAGCCGGGAGCTATTTAACGAGGTTTAGGGTAGGCTCCCAGGTCACTGCGCAGGACTGCTCCGTTACAGGTGGGCAGGGGAGGCTGCTCCGTTACAGGTGGGCAGGGGAGGCGGCTCCGTTACAGGTGGGCAGGGGAGGCGGCTGCGTTACAGGTGTGCAGGGGAGGCGGCTGCGTTACAGGTGGGCGGGGGAGGCGGCTGCGTTACAGGTGGGC\t*\tSA:Z:chr1,934806,+,163S456M,60,8;\tMD:Z:140T45G3G27G39G30A12C14\tRG:Z:GATKSVContigAlignments\tNM:i:7\tAS:i:282\tXS:i:0", true);
        final AlignmentInterval normalTwo = SVTestUtils.fromSAMRecordString("asm000012:tig00003\t0\tchr1\t934806\t60\t163S456M\t*\t0\t0\tTCCTGGAAGGTTTAGAGCCCAGCCTGGGAGTCTTTGGTGCTGAAACGGATCTGCTTAGGGGCAGCCTTGGATTAGCCCAGCTCCAGCCAGCCCAGGTCAGGGGAGCCGGGAGCTATTTAACGAGGTTTAGGGTAGGCTCCCAGGTCACTGCGCAGGACTGCTCCGTTACAGGTGGGCAGGGGAGGCTGCTCCGTTACAGGTGGGCAGGGGAGGCGGCTCCGTTACAGGTGGGCAGGGGAGGCGGCTGCGTTACAGGTGTGCAGGGGAGGCGGCTGCGTTACAGGTGGGCGGGGGAGGCGGCTGCGTTACAGGTGGGCGGGCGGTGCTGCAGGAGGACTGCTCAGGGAGTGGCGCCTGGACCCTGAGCCCCTTCTCTGCTGACTGGGGAGAGGCTCACGGAACCGGGAAGGGGTGGAGGGCCGTGCTCCACACAGTTCGTCTCATTGCTCTCTGGGACTCTGTGGATGTGGGATTGGGCTGAATTAGCAAGAAGAGGAGAAATGAGGGAAGAAAAGAGTTAAATGCATGTTGATTCCAAGCCCCCGCCTGCCGGGGGGACAGCGGGAGGTTGGAGCACGCAGCCCTGGTGCCTGGTGCGAGCTGCACGTGTCTGCCGGTG\t*\tSA:Z:chr1,933803,+,317M302S,60,7;\tMD:Z:14G8G18G12G14G24G2G32G324\tRG:Z:GATKSVContigAlignments\tNM:i:8\tAS:i:416\tXS:i:147", true);
        data.add(new Object[]{Arrays.asList(normalOne, normalTwo), 416, null});
        return data.toArray(new Object[data.size()][]);
    }

    @Test(groups = "sv", dataProvider = "forTestSpecialChanelForSingleNonCanonicalMappings")
    public void testSpecialChanelForSingleNonCanonicalMappings(final List<AlignmentInterval> configuration,
                                                               final int maxCanonicalAS,
                                                               final AlignmentInterval expectedOutput) {
        final AlignmentInterval result = AssemblyContigAlignmentsConfigPicker.getBetterNonCanonicalMapping(
                b38_canonicalChromosomes, configuration, maxCanonicalAS);
        Assert.assertEquals(result, expectedOutput);
    }

    @Test(groups = "sv")
    public void testHeuristicSpeedUpWhenFacingManyMappings() {
        final AlignedContig alignedContig = SVTestUtils.fromPrimarySAMRecordString("asm010147:tig00010\t16\tchr6\t31427489\t43\t4S54M2I26M7D22M4I33M4I70M2I109M2I103M1525S\t*\t0\t0\tATTCTATATATATATTCTATATATATATTCTATATATATATTCTATATATATATTCTATGTATGTATTCTATATATATATTTTATATATTTATTCTATGTATATATTCTACATATATATTCTATATATATATTCGATATATGTTCGATATATATATTTGATATATATATTCTATATATATATTCTATATATATATTCTATATATATTCTATATATATTCTATATATATATATTCTATATATATTCTATATATATATTCTATATATATATTCTATATATATTCTATATATATTCTATATATATATTCTATATATATTCCATATATATATTCTATATATATATTCCATATATATTCCATATATATATTCTATATATATTCCATATATATATTCCACATATATATTCCATATATATATTCCACACATATATTCTATATATATATTCCATACATATATTCTATATATATATATTCCATACATATATTCTATATATATATTCCATACATATATTCTATATATATATATTCCATACATATATTCTATATATATATATTCCATACATATATTCTATATATATATATTCCATACATATATTCTATATATGTATATTCCATACATATATTCCATATATATATTCCATACATATATTCCATATATGTATATTCCATATATATATTCCATATATATATATTCCATATATATATTCCATATATATATTCCATATATATGTTCCATATATATATTCCATATATATGTTCCATATATATATTCTATATATATGTAACATATATATATTCCATATATATGGAACATATATATATTCTATATATATGGAACATATATATATTCTATATATATGGAACATATATATATTCTATATATCTGTTCCATATATATATTCTATATATCTGTTCCATATATATATTCTATATATCTGTTCCATATATATGTTCTATATATCTGTTCCATATATATATTCTATATATCTGTTCCATATATATATTCTATATATCTGTTCCATATATATATTCTATATATATATTCTATACATTCTATATATAATATATATATTCTATATATTCTATATATAATATATATATTCTATGTATATATTCTATATATAATATATATATTCTATGTATATATTCTATATATATTCTATATATATTCTATGTATATATTCTATATATATTCTATATATATTCCATATATATTCTATATATATTCTATGTATATTCGATATATATATTCTATATATATTCTATATATTCGATATATATATTCTATATATATTCTATATATTCGATACATATATTCTATATATAATCTATATATTATATATATTCTATATATATATCCTATATATATTCTATATATTCTATATATATCCCATATATATTCTATATATTCTATATATACATCCCATATATATCCTGTATATCCTATATATATATCCTATATATATCCTGTATATCCTATATATATATCCTATATATATATCCTGTATATCCTATATATATATATCCTATATATATCCTATATATCCTATATATATCCTATATATGTATCCTATATATACATCCTTTATATCCTATACATATATCCTATATGTCCTATACATATATCCTATATATATCCTATATATCCTATATATATATCCTATATATATATTCGATATATATCCTATATATCCTATATATATATCCCATATATATCCTATATATCCCATATATATCCTATATATCCTATATATCCTATATATATATCCTATATATATCCTATATATATCCTATATATATATCCTGTATATATATCCTATATATATATATCCTGTATATATATCCTATATATATATCCTGTATATATATCCTATATATATATATCCTGTATATATATCCTATATATATATATCCTGTATATATATCCTATATATATATATCCTGTATATATATCCTATATATA\t*\tSA:Z:chr6,31428609,-,1753H65M9D61M4I77M,17,22,113;chr6,31428242,-,883H188M4D95M794H,43,36,103;chr3,152694227,+,1245H26M2I118M569H,17,9,91;chr7,15531019,-,1172H147M7I62M2D28M544H,19,31,86;chr6,31428246,-,679H125M1156H,31,9,80;chr4,12386256,-,780H100M1080H,0,7,65;chrX,50228609,+,739H24M2D22M4I49M1122H,16,7,52;chr3,151030799,+,150H24M2D35M2D57M1694H,43,10,50;chr3,151030872,+,399H47M1514H,10,0,47;chr6,31428687,-,1467H40M453H,43,1,35;chr6_GL000253v2_alt,2736084,-,215M4I26M4I142M1569H,7,38,193;chr6_GL000256v2_alt,2730310,-,1017H129M13D57M15D57M2D38M9I134M2I58M459H,30,76,177;chrUn_JTFH01001202v1_decoy,266,-,306H38M6D23M6D89M4I24M1D139M2D64M1273H,34,45,148;chrUn_JTFH01001628v1_decoy,267,+,918H273M4I24M2I33M4D28M2D55M623H,60,52,137;\tMD:Z:57A17C4^TCTATTC3A8A3C21C5T18C0T34T0C1A92A0T1C22T23T10T23T12T1T10T12T1T1T13\tRG:Z:GATKSVContigAlignments\tNM:i:46\tAS:i:175\tXS:i:138",
                true);

        final GoodAndBadMappings goodAndBadMappings =
                AssemblyContigAlignmentsConfigPicker
                        .speedUpWhenTooManyMappings(alignedContig, CpxSVInferenceTestUtils.hg38CanonicalChromosomes, 175);

        final List<AlignmentInterval> alignments = alignedContig.getAlignments();
        final List<AlignmentInterval> expectedBad = Arrays.asList(new AlignmentInterval("chr3,151030872,+,399H47M1514H,10,0,47"),
                new AlignmentInterval("chr4,12386256,-,780H100M1080H,0,7,65"));
        alignments.removeAll(expectedBad);
        Assert.assertEquals(goodAndBadMappings.getGoodMappings(), alignments);
        Assert.assertEquals(goodAndBadMappings.getBadMappings(), expectedBad);
    }

    @DataProvider(name = "forConfigurationSorting")
    private Object[][] forConfigurationSorting() {
        final List<Object[]> data = new ArrayList<>(20);
        // case for two equally-good configurations, one has fewer alignments
        String sam = "asm001160:tig00000\t16\tchr1\t93876139\t60\t516S1317M\t*\t0\t0\tCATGTTGCCCAAGCCAGTCTTGAACTCCAGGGCTCAAAATGCTGAAATTACAGGCACGAGTCACTTACTGCTCTTAACAATCACGTACAAAAATCTTAACATATGATTTTTTTTTTTTTTTTTTGAGACAACATCTCCCTCCATTGCCCAGGCTGGAGTGCAGCGGCACAATCATGGCTCACCGCAGCCTCAATGTCCAGGGCTCAAGCAATCCTCCCACCTCAGCTTCCCAAGTAGCTGGGACCACAGGCGCACAGGGCACGGCTAATTTAAAAAAAATTTTTTGTGTAGAGATAGGGTCTCCTTATATTGCCCAGGCTGATCTCAAACACCTACTTGGGCTCAAGTGATCCTCCTGCCTCAGCCTCACAAAGTGCTGGGATTACAGGCATGAGTCACTGCATCCAACAGATTGATTTCTAATATGTCACCAAAAGGAGCACCTTTAGCTATGATTGGTGGGAAAAATATGACTAAAATAGGTATCCAAAAAGACAAGGGAAATGCTGGATAGAAGAGCCATTCCATGAAGAACCCAAGGCAGTGATTTTCTCATTCCCCAGGCTAACATTTCATATTTTTATGGTAAATTAACCACTTGAAATACATGTATCAAAAACTTATAAAAATAAAGGAAAAACTTACAGTTTAGCCTTTGTGCTATTTAGGAAGTCTTCTTCATCACTAAACTCATCTTCATTTTCGTCATGGTCTGATGAATCTTCTTCACTTTTTTCATCCTCTTCCTCTTCTTTTTCTTCCTCAATGGCAACCTCACTTGCCTTGTCTTCCTCTTCCAAGTAAAAATTTTTATCAGCACTCATTCCAGGAGTTGTGTCAATTACAAACAATGCATTGTCACATGACAGACTTCCTGTGTCTCCACTTAATGACTCCCTTTGGCCACTATTTTCAACAAAACATAAAGTATCCTCTTCATTCTCACTGTTTTCAGACTGTTGGCTTTCATCACTGCTGAGAACTAGTAAGACAGAATTATCTTTACCCTGAGATGTGTTGGGCGCAGACGTGTATAGTTTGGTATCACATTCAAAATCTACATTCCCTTCACTGTTCATGTCTTCACTGACACTTATAACTGTGGACTCTTCTTCATCATCACTACCACCACAATCACCAAACTTTGTCAAGTCACTTGCTTTTATGGGGCTCTTTTTGTTGTTATTCCATCTGCCTACTTCCACAGTTGCAAATGTTTGAGTTAATGATTTCATTACAGCCTCAGAGTTCAGATTAGAGTGCACTGATACAGCATTTTTATTTTGGGGGGTTGAATGTCTCTGAGAAACTAACTGTTGAAGGCTAGTGTCCTGAAGTTCAGAAAGATTCTTCAGCTGAGAACTTTTCTCATTAATTTCTTTCCCCTCATCTGTTATTCCATTGGCATCTTCATCCAAATCCTTACAATTCTGTTTTGTTTCTTTAAGAGATTCAACATTGGCCTGTTCGTGCACTGTTAATATATTTTCTGAACTTCTGTGGGAGAAATCATCATCAAAGTCATTATTATAGAAATTTGGCTTATTTATCTCAGAAAGAGATCTTGCTTGTAAATGGGAAGTTTGTCTGGTATCTGAATCCTCTGAATTCACAGGTGTACCCACGATCTGTTTCTCATTTCCTGGTACAATCTTACTATCTTTCTTTTCAGTTTGTGCCTTTAATTTCCTCTGCATACTCCTGGTTCTTCTAGTTGCAATTCCAGAGAATGAAATGTCTGAGCTTGATGTCTCAGCATCAGATATAGCTTCTGTATGAGATTCTTGGCTTGGATCTGTCAGAGATTTAGCCTTACTTCTTCTGGCTCCTGTA\t*\tSA:Z:chr1,61662787,-,165H74M1594H,12,2,64;chr15,43085606,+,1427H65M341H,0,2,55;chr10,96642377,+,1660H67M106H,60,5,42;chrUn_JTFH01001621v1_decoy,641,-,106M2I408M1317H,60,5,481;\tMD:Z:1317\tRG:Z:GATKSVContigAlignments\tNM:i:0\tAS:i:1317\tXS:i:0";
        AlignedContig alignedContig = SVTestUtils.fromPrimarySAMRecordString(sam, true);

        data.add(new Object[]{alignedContig,
                Arrays.asList(
                        new AssemblyContigWithFineTunedAlignments(
                                new AlignedContig(alignedContig.getContigName(), alignedContig.getContigSequence(),
                                        Arrays.asList(alignedContig.getAlignments().get(0), alignedContig.getAlignments().get(1))),
                                alignedContig.getAlignments().subList(2,alignedContig.getAlignments().size()).stream().map(AlignmentInterval::toPackedString).collect(Collectors.toList()),
                                true,
                                (AlignmentInterval)null
                        ),
                        new AssemblyContigWithFineTunedAlignments(
                                new AlignedContig(alignedContig.getContigName(), alignedContig.getContigSequence(),
                                        Arrays.asList(alignedContig.getAlignments().get(0), alignedContig.getAlignments().get(1), alignedContig.getAlignments().get(4))),
                                alignedContig.getAlignments().subList(2,4).stream().map(AlignmentInterval::toPackedString).collect(Collectors.toList()),
                                true,
                                (AlignmentInterval)null)
                )
        });

        // case for two equally-good configurations, having same num of alignments, one has lower total NM
        sam = "asm000168:tig00027\t0\tchr1\t4939534\t60\t54S139M96S\t*\t0\t0\tGTCCTCCGTATGACGTCAGTGTCCTCCATATGACATCAATATCCTCCATATGACATCAATATCCTCCATATGATGTCAGTGTGCTCCATATGACATCAATATCCTCCATATGATGTCAATATCCTGCGTATGATGTCAATATCCTCCGTATGATGTCAATATCCTCCATATGATGTCAATATCCTCTGTATGATGTCAGTGTCCTCCATATGATGTCAATCGCCTCCATATGATGCCAATATCCTCCGTATGATGTCAATGCCCTCCGTATGATGTCAATGTCCTCCGT\t*\tSA:Z:chr1,4939535,+,155H134M,60,15,61;chr1,4939436,+,66M223H,23,3,51;chrUn_JTFH01000538v1_decoy,1338,-,153M136H,60,1,148;\tMD:Z:14A13C10T0G5G24C52G1G12\tRG:Z:GATKSVContigAlignments\tNM:i:8\tAS:i:99\tXS:i:45";
        alignedContig = SVTestUtils.fromPrimarySAMRecordString(sam, true);

        data.add(new Object[]{alignedContig,
                Arrays.asList(
                        new AssemblyContigWithFineTunedAlignments(
                                new AlignedContig(alignedContig.getContigName(), alignedContig.getContigSequence(),
                                        Arrays.asList(alignedContig.getAlignments().get(0), alignedContig.getAlignments().get(1), new AlignmentInterval("chrUn_JTFH01000538v1_decoy,1338,-,153M136H,60,1,148"))),
                                Collections.singletonList(new AlignmentInterval("chr1,4939535,+,155H134M,60,15,61").toPackedString()),
                                true,
                                (AlignmentInterval)null
                        ),
                        new AssemblyContigWithFineTunedAlignments(
                                new AlignedContig(alignedContig.getContigName(), alignedContig.getContigSequence(),
                                        Arrays.asList(alignedContig.getAlignments().get(0), alignedContig.getAlignments().get(1), new AlignmentInterval("chr1,4939535,+,155H134M,60,15,61"))),
                                        Collections.singletonList(new AlignmentInterval("chrUn_JTFH01000538v1_decoy,1338,-,153M136H,60,1,148").toPackedString()),
                                true,
                                (AlignmentInterval)null)
                )
        });

        return data.toArray(new Object[data.size()][]);
    }
    @Test(groups = "sv", dataProvider = "forConfigurationSorting")
    public void testConfigurationSorting(final AlignedContig alignedContig,
                                         final List<AssemblyContigWithFineTunedAlignments> expectedRepresentationsInOrder) {

        List<AssemblyContigWithFineTunedAlignments> result =
                IteratorUtils.toList(
                        AssemblyContigAlignmentsConfigPicker.reConstructContigFromPickedConfiguration(
                                new Tuple2<>(new Tuple2<>(alignedContig.getContigName(), alignedContig.getContigSequence()),
                                        AssemblyContigAlignmentsConfigPicker.pickBestConfigurations(alignedContig,
                                                CpxSVInferenceTestUtils.hg38CanonicalChromosomes, 0.0))));

        Assert.assertEquals(result, expectedRepresentationsInOrder);
    }


    @DataProvider(name = "forSpecialCaseGapSplit")
    private Object[][] forSpecialCaseGapSplit() {
        final List<Object[]> data = new ArrayList<>(20);

        AlignmentInterval noGap;
        AlignmentInterval gapped;
        // case one: gapped alignment provides worse coverage
        noGap = new AlignmentInterval(new SimpleInterval("chr1", 1_000_001, 1_000_950),
                1, 950, TextCigarCodec.decode("950M50S"),
                true, 60, 0, 950, ContigAlignmentsModifier.AlnModType.NONE);
        gapped = new AlignmentInterval(new SimpleInterval("chr1", 1_000_101, 1_001_200),
                101, 1000, TextCigarCodec.decode("100S300M200D600M"),
                true, 60, 200, 900, ContigAlignmentsModifier.AlnModType.NONE);
        data.add(new Object[]{new Tuple2<>(noGap, gapped),
                false,
                new GoodAndBadMappings(Collections.singletonList(noGap),
                        Arrays.asList(new AlignmentInterval(new SimpleInterval("chr1", 1_000_101, 1_000_400), 101, 400, TextCigarCodec.decode("100S300M600S"), true, 60, AlignmentInterval.NO_NM, AlignmentInterval.NO_AS, ContigAlignmentsModifier.AlnModType.FROM_SPLIT_GAPPED_ALIGNMENT),
                                      new AlignmentInterval(new SimpleInterval("chr1", 1_000_601, 1_001_200), 401, 1000, TextCigarCodec.decode("400S600M"), true, 60, AlignmentInterval.NO_NM, AlignmentInterval.NO_AS, ContigAlignmentsModifier.AlnModType.FROM_SPLIT_GAPPED_ALIGNMENT)))
        });

        // case two: gapped alignment provides better coverage with a D-gap
        noGap = new AlignmentInterval(new SimpleInterval("chr1", 1_000_001, 1_000_500),
                1, 500, TextCigarCodec.decode("500M"),
                true, 60, 0, 500, ContigAlignmentsModifier.AlnModType.NONE );

        gapped = new AlignmentInterval(new SimpleInterval("chr1", 1_000_101, 1_001_200),
                101, 1000, TextCigarCodec.decode("100S300M200D600M"),
                true, 60, 200, 900, ContigAlignmentsModifier.AlnModType.NONE);
        data.add(new Object[]{new Tuple2<>(noGap, gapped),
                true,
                new GoodAndBadMappings(Arrays.asList(new AlignmentInterval(new SimpleInterval("chr1", 1_000_101, 1_000_400), 101, 400, TextCigarCodec.decode("100S300M600S"), true, 60, AlignmentInterval.NO_NM, AlignmentInterval.NO_AS, ContigAlignmentsModifier.AlnModType.FROM_SPLIT_GAPPED_ALIGNMENT),
                                                     new AlignmentInterval(new SimpleInterval("chr1", 1_000_601, 1_001_200), 401, 1000, TextCigarCodec.decode("400S600M"), true, 60, AlignmentInterval.NO_NM, AlignmentInterval.NO_AS, ContigAlignmentsModifier.AlnModType.FROM_SPLIT_GAPPED_ALIGNMENT)),
                        Collections.singletonList(noGap))
        });

        // case three: gapped alignment provides better coverage with a I-gap
        gapped = new AlignmentInterval(new SimpleInterval("chr1", 1_000_101, 1_000_850),
                101, 1000, TextCigarCodec.decode("100S300M150I450M"),
                true, 60, 150, 750, ContigAlignmentsModifier.AlnModType.NONE);
        data.add(new Object[]{new Tuple2<>(noGap, gapped),
                true,
                new GoodAndBadMappings(Arrays.asList(new AlignmentInterval(new SimpleInterval("chr1", 1_000_101, 1_000_400), 101, 400, TextCigarCodec.decode("100S300M600S"), true, 60, AlignmentInterval.NO_NM, AlignmentInterval.NO_AS, ContigAlignmentsModifier.AlnModType.FROM_SPLIT_GAPPED_ALIGNMENT),
                                                     new AlignmentInterval(new SimpleInterval("chr1", 1_000_401, 1_000_850), 551, 1000, TextCigarCodec.decode("550S450M"), true, 60, AlignmentInterval.NO_NM, AlignmentInterval.NO_AS, ContigAlignmentsModifier.AlnModType.FROM_SPLIT_GAPPED_ALIGNMENT)),
                        Collections.singletonList(noGap))
        });

        return data.toArray(new Object[data.size()][]);
    }
    @Test(groups = "sv", dataProvider = "forSpecialCaseGapSplit")
    public void testSpecialCaseGapSplit(final Tuple2<AlignmentInterval, AlignmentInterval> nonGappedAndGappedAlignment,
                                        final boolean expectedGappedAlignmentOffersBetterCoverage,
                                        final GoodAndBadMappings expectedOutput) {

        Assert.assertEquals(
                AssemblyContigAlignmentsConfigPicker
                        .gappedAlignmentOffersBetterCoverage(nonGappedAndGappedAlignment._2, nonGappedAndGappedAlignment._1),
                expectedGappedAlignmentOffersBetterCoverage
        );

        Assert.assertEquals(
                AssemblyContigAlignmentsConfigPicker.splitGaps(
                        new GoodAndBadMappings(Arrays.asList( nonGappedAndGappedAlignment._1, nonGappedAndGappedAlignment._2))),
                expectedOutput
        );
    }
}
