package org.broadinstitute.hellbender.tools;


import htsjdk.samtools.SAMRecord;
import htsjdk.samtools.SamReader;
import htsjdk.samtools.SamReaderFactory;
import htsjdk.samtools.util.PeekableIterator;
import htsjdk.samtools.util.RuntimeIOException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.broadinstitute.barclay.argparser.Argument;
import org.broadinstitute.barclay.argparser.ArgumentCollection;
import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;
import org.broadinstitute.barclay.argparser.WorkflowOutput;
import org.broadinstitute.barclay.help.DocumentedFeature;
import org.broadinstitute.hellbender.cmdline.CommandLineProgram;
import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;
import org.broadinstitute.hellbender.cmdline.argumentcollections.ReferenceInputArgumentCollection;
import org.broadinstitute.hellbender.cmdline.argumentcollections.RequiredReferenceInputArgumentCollection;
import org.broadinstitute.hellbender.engine.ReferenceDataSource;
import org.broadinstitute.hellbender.tools.reprocessing.TemplateReadCollection;
import org.broadinstitute.hellbender.utils.runtime.ProgressLogger;
import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

/**
 * Compare two aligners. This tool takes in two BAM files, each of which is the output of a different aligner run
 * on the same set of reads. It compares the alignments and generates a truth set of labels for each read, with an option
 * to cap the number of reads in the truth set, or to randomly sample a subset of reads.
 *
 */
@CommandLineProgramProperties(
        summary = CompareTwoAligners.USAGE_SUMMARY + CompareTwoAligners.USAGE_DETAILS,
        oneLineSummary = CompareTwoAligners.USAGE_SUMMARY,
        programGroup = DiagnosticsAndQCProgramGroup.class)
@DocumentedFeature
public class CompareAlignersGetTruthLabels extends CommandLineProgram {
    public static final String USAGE_SUMMARY = "Compare two aligners and generate truth labels for reads. ";
    public static final String USAGE_DETAILS = "This tool compares two BAM files, each generated by a different aligner, " +
            "and produces a truth set of labels for each read. The truth set can be capped to a maximum number of reads, " +
            "or a random subset can be sampled. This is useful for evaluating the performance of different aligners on the same dataset.";

    @ArgumentCollection
    final ReferenceInputArgumentCollection reference = new RequiredReferenceInputArgumentCollection();

    @Argument(
            doc = "The output file where the truth labels will be written.",
            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,
            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME
    )
    @WorkflowOutput
    private File output = null;

    @Argument(doc = "The first BAM file to compare. This will be used as the truth set for comparison.")
    public File firstBam;

    @Argument(doc = "The second BAM file to compare. This will be compared against the first BAM file to generate truth labels.")
    public File secondBam;

    @Argument(doc="Maximum number of reads to output. Note that if the BAM contains less reads than this number all" +
            " reads in the BAM will be included in the output." )
    public int maxReadsInTruthSet = 1_000_000;

    @Argument(doc = "Minimum mapping quality for reads to be included in the truth set. Reads with lower mapping quality" +
            " in either BAM files will be ignored.  ")
    public int minMappingQuality = 20;

    private static final Logger logger = LogManager.getLogger();
    private static final ProgressLogger progressLogger = new ProgressLogger(logger, 1_000_000, "Processed", "records");

    private boolean readsMatch(final SAMRecord firstRead, final SAMRecord secondRead) {
        // check if either read is unmapped, if both are unmapped, they match
        if (firstRead.getReadUnmappedFlag() && secondRead.getReadUnmappedFlag()) {
            return true; // both reads are unmapped, they match
        }

        if (firstRead.getReadUnmappedFlag() || secondRead.getReadUnmappedFlag()) {
            return false; // one read is unmapped, they do not match
        }

        return firstRead.getReadName().equals(secondRead.getReadName()) &&
               firstRead.getReferenceName().equals(secondRead.getReferenceName()) &&
               firstRead.getAlignmentStart() == secondRead.getAlignmentStart();
    }

    private boolean skipReads(final SAMRecord firstRead, final SAMRecord secondRead, final int minMappingQuality) {
        // Skip reads that do not meet the minimum mapping quality
        return firstRead.getMappingQuality() < minMappingQuality || secondRead.getMappingQuality() < minMappingQuality;
    }

    @Override
    protected Object doWork() {
        final SamReaderFactory samReaderFactory = SamReaderFactory.makeDefault().referenceSequence(reference.getReferencePath());
        int totalReadsWritten = 0;
        try (final SamReader firstReader = samReaderFactory.open(firstBam);
             final SamReader secondReader = samReaderFactory.open(secondBam);
             final FileWriter writer = new FileWriter(output)) {
            // Write header to the output file
            writer.write("seq" + "\t" + "label" + "\n");

            final PeekableIterator<SAMRecord> firstPeekableIterator = new PeekableIterator<>(firstReader.iterator());
            final PeekableIterator<SAMRecord> secondPeekableIterator = new PeekableIterator<>(secondReader.iterator());

            while (firstPeekableIterator.hasNext() && secondPeekableIterator.hasNext()) {
                final TemplateReadCollection firstTemplateReads = new TemplateReadCollection(firstPeekableIterator, progressLogger);
                final TemplateReadCollection secondTemplateReads = new TemplateReadCollection(secondPeekableIterator, progressLogger);

                // Query names must match
                if (!firstTemplateReads.getQueryName().equals(secondTemplateReads.getQueryName())) {
                    throw new IllegalStateException("Query names do not match: " + firstTemplateReads.getQueryName() + " vs " + secondTemplateReads.getQueryName());
                }

                if (skipReads(firstTemplateReads.getFirstInPairRecord(), secondTemplateReads.getFirstInPairRecord(), minMappingQuality) ||
                   skipReads(firstTemplateReads.getSecondInPairRecord(), secondTemplateReads.getSecondInPairRecord(), minMappingQuality)) {
                    continue; // Skip this pair of reads if either does not meet the minimum mapping quality
                }
                int firstInPairLabel = readsMatch(firstTemplateReads.getFirstInPairRecord(), secondTemplateReads.getFirstInPairRecord()) ? 1 : 0;
                writer.write(new String(firstTemplateReads.getFirstInPairRecord().getReadBases(), StandardCharsets.UTF_8) + "\t" +
                        firstInPairLabel + "\n");
                int secondInPairLabel = readsMatch(firstTemplateReads.getSecondInPairRecord(), secondTemplateReads.getSecondInPairRecord()) ? 1 : 0;
                writer.write(new String(firstTemplateReads.getSecondInPairRecord().getReadBases(), StandardCharsets.UTF_8) + "\t" +
                        secondInPairLabel + "\n");
                totalReadsWritten += 2; // Two reads per template
                if (totalReadsWritten >= maxReadsInTruthSet) {
                    break; // Stop if we have reached the maximum number of reads to output
                }
            }
        } catch (IOException e) {
            throw new RuntimeIOException("Error opening file", e);
        }
        return 0;
    }
}

