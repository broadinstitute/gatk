package org.broadinstitute.hellbender.tools.exome.acsconversion;


import org.broadinstitute.hellbender.exceptions.UserException;
import org.broadinstitute.hellbender.tools.exome.ACNVModeledSegment;
import org.broadinstitute.hellbender.tools.exome.Genome;
import org.broadinstitute.hellbender.tools.exome.ModeledSegment;
import org.broadinstitute.hellbender.tools.exome.SegmentUtils;
import org.broadinstitute.hellbender.tools.exome.cnlohcaller.CNLOHBalancedCall;
import org.broadinstitute.hellbender.tools.exome.cnlohcaller.CNLOHCall;
import org.broadinstitute.hellbender.utils.SimpleInterval;
import org.broadinstitute.hellbender.utils.Utils;
import org.broadinstitute.hellbender.utils.param.ParamUtils;
import org.broadinstitute.hellbender.utils.tsv.DataLine;
import org.broadinstitute.hellbender.utils.tsv.TableUtils;
import org.broadinstitute.hellbender.utils.tsv.TableWriter;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Static class for writing out legacy AllelicCapSeg formatted files from ACNV output.
 */
public class ACSModeledSegmentUtils {

    /**
     * This was taken since it approximates 1 sigma from 95% confidence intervals, when used to divide the credible interval width.
     * Made larger at user request.
     */
    public static final double DIVISOR = 2.0;

    private ACSModeledSegmentUtils() {
    }

    /**
     * Writes a list of segments represented by {@link ACNVModeledSegment} to a file with header:
     * <p>
     *      Chromosome | Start.bp | End.bp | n_probes | length | n_hets | f | tau | sigma.tau | mu.minor | sigma.minor | mu.major | sigma.major | SegLabelCNLOH
     * </p>
     *
     * This header is produced by the Broad Institute CGA tool, AllelicCapSeg.  Please note that SegLabelCNLOH is not populated properly.
     */
    public static void writeACNVModeledSegmentFileAsAllelicCapSegFile(final File outFile,
                                                                      final List<CNLOHCall> cnlohCalls,
                                                                      final Genome genome) {
        Utils.nonNull(genome, "The genome cannot be null.");
        Utils.nonNull(cnlohCalls, "Calls cannot be null.");

        final List<ACSModeledSegment> acsModeledSegments = convertACNVSegmentsToACSSegments(cnlohCalls, DIVISOR, genome);
        try (final TableWriter<ACSModeledSegment> writer =
                     TableUtils.writer(outFile, ACSTableColumn.COLUMNS,
                             //lambda for creating DataLine with sampleName and segment fields
                             (segment, dataLine) -> {
                                 dataLine.append(segment.getContig()).append(segment.getStart()).append(segment.getEnd())
                                         .append(segment.getTargetCount())
                                         .append(segment.getEnd() - segment.getStart())
                                         .append(segment.getHetCount())
                                         .append(segment.getF())
                                         .append(segment.getTau()).append(segment.getSigmaTau())
                                         .append(segment.getMuMinor()).append(segment.getSigmaMinor())
                                         .append(segment.getMuMajor()).append(segment.getSigmaMajor())
                                         .append(segment.getSegLabelCNLOH());
                             }
                     )) {
            for (final ACSModeledSegment segment : acsModeledSegments) {
                writer.writeRecord(Utils.nonNull(segment, "List of segments contains a null."));
            }
        } catch (final IOException e) {
            throw new UserException.CouldNotCreateOutputFile(outFile, e);
        }
    }

    /**
     * Convert the ACNV modeled segments into the ACS modeled segments.
     *
     * @param cnlohCalls segments and calls generated by CNLoHCaller.  Never {@code null}
     * @param divisor used for estimating the sigma for the segments
     * @param genome Populated genome object.  Never {@code null}
     * @return list of segments using the CGA ACS model
     */
    public static List<ACSModeledSegment> convertACNVSegmentsToACSSegments(final List<CNLOHCall> cnlohCalls, final double divisor, final Genome genome) {
        ParamUtils.isPositive(divisor, "Divisor must be greater than 0.");
        Utils.nonNull(cnlohCalls);
        Utils.nonNull(genome);

        return cnlohCalls.stream().map(c -> convertACNVSegmentToACSSegment(c.getAcnvSegment(), divisor, genome, c.getBalancedCall() == CNLOHBalancedCall.BALANCED))
                .collect(Collectors.toList());
    }

    /**
     *  Convert a single ACNV Modeled segment
     *
     *  sigmaTau is generated by taking the confidence interval around the copy ratio estimate and dividing it by the divisor (currently, set to 2.0
     *   given by CGA)
     *
     * @param acnvModeledSegment segment generated by ACNV.  Never {@code null}
     * @param divisor used for estimating the sigma for the segments
     * @param genome Populated genome object.  Never {@code null}
     * @return segment using the CGA ACS model
     */
    public static ACSModeledSegment convertACNVSegmentToACSSegment(final ACNVModeledSegment acnvModeledSegment, final double divisor, final Genome genome, final boolean isSegmentBalanced) {

        final double segmentMeanInLog2CR = acnvModeledSegment.getSegmentMeanPosteriorSummary().getCenter();
        final double fACNV = acnvModeledSegment.getMinorAlleleFractionPosteriorSummary().getCenter();
        final double f = isSegmentBalanced && !Double.isNaN(fACNV) ? 0.5 : fACNV;
        final double tau = Math.pow(2, segmentMeanInLog2CR) * 2.0;
        final double tauWidth = Math.pow(2, acnvModeledSegment.getSegmentMeanPosteriorSummary().getUpper()) - Math.pow(2, acnvModeledSegment.getSegmentMeanPosteriorSummary().getLower());
        final double sigmaTau = tauWidth / divisor;
        final double muMinor = tau * f;
        final double fWidth = acnvModeledSegment.getMinorAlleleFractionPosteriorSummary().getUpper() - acnvModeledSegment.getMinorAlleleFractionPosteriorSummary().getLower();
        final double sigmaMinor = fWidth / divisor;
        final double muMajor = tau * (1 - f);
        final double sigmaMajor = sigmaMinor;
        final int targetCount = genome.getTargets().targetCount(acnvModeledSegment.getInterval());
        final int segLabelCNLOH = 2;
        final int hetCount = genome.getSNPs().targetCount(acnvModeledSegment.getInterval());
        return new ACSModeledSegment(acnvModeledSegment.getInterval(), ModeledSegment.NO_CALL, targetCount, segmentMeanInLog2CR,
                hetCount, f, sigmaTau, muMinor, sigmaMinor, muMajor, sigmaMajor, segLabelCNLOH);
    }

    /**
     * Read in legacy CGA ACS format.
     *
     * @param acsSegFile Never {@code null}.  Produced by Allelic CapSeg or legacy output in GATK ACNV
     * @return Never {@code null}
     */
    public static List<ACSModeledSegment> readACSFile(final File acsSegFile) {
        Utils.nonNull(acsSegFile);
        Utils.regularReadableUserFile(acsSegFile);
        return SegmentUtils.readSegmentFile(acsSegFile, ACSTableColumn.COLUMNS, ACSModeledSegmentUtils::toACSModeledSegment);
    }

    private static ACSModeledSegment toACSModeledSegment(final DataLine dataLine) {
        final SimpleInterval interval = SegmentUtils.toInterval(dataLine, ACSTableColumn.CHROMOSOME.toString(),
                ACSTableColumn.START.toString(), ACSTableColumn.END.toString());
        final int targetCount = dataLine.getInt(ACSTableColumn.NUM_PROBES);
        final double segmentMeanInLog2CR = dataLine.getDouble(ACSTableColumn.TAU.toString())/2.0;
        final int hetCount = dataLine.getInt(ACSTableColumn.NUM_HETS.toString());
        final double f = dataLine.getDouble(ACSTableColumn.F.toString());
        final double sigmaTau = dataLine.getDouble(ACSTableColumn.SIGMA_TAU.toString());
        final double muMinor = dataLine.getDouble(ACSTableColumn.MU_MINOR.toString());
        final double muMajor = dataLine.getDouble(ACSTableColumn.MU_MAJOR.toString());
        final double sigmaMinor = dataLine.getDouble(ACSTableColumn.SIGMA_MINOR.toString());
        final double sigmaMajor = dataLine.getDouble(ACSTableColumn.SIGMA_MAJOR.toString());
        final int segLabelCNLOH = dataLine.getInt(ACSTableColumn.SEGLABELCNLOH.toString());
        return new ACSModeledSegment(interval, ModeledSegment.NO_CALL, targetCount, segmentMeanInLog2CR, hetCount, f,
                sigmaTau, muMinor, sigmaMinor, muMajor, sigmaMajor, segLabelCNLOH);
    }
}
