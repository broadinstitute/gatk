buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'org.kt3k.gradle.plugin:coveralls-gradle-plugin:2.3.1'
        classpath 'com.github.jengelman.gradle.plugins:shadow:1.2.2'
    }
}

plugins {
    id "de.undercouch.download" version "1.2"
}

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'application'
apply plugin: "jacoco"
apply plugin: 'com.github.kt3k.coveralls'
apply plugin: 'maven'
apply plugin: 'signing'
apply plugin: 'com.github.johnrengelman.shadow'

mainClassName = "org.broadinstitute.hellbender.Main"

import org.gradle.internal.os.*
def isMacOsX = OperatingSystem.current().macOsX
def customJarPath = hasProperty("custom.jar.dir") ? property("custom.jar.dir") : null;

repositories {
    mavenCentral()
    maven {
      url "https://oss.sonatype.org/content/groups/public"
    }
    maven {
        url "https://repository.cloudera.com/artifactory/cloudera-repos/" // spark-dataflow
    }

    // Locations for finding HDF and HDFJava jar files
    //  Please note that this is only for the jar files, not the jni shared native libraries (.so files --
    //   E.g. libjhdf5.so).  Instructions for those are found in README.md.
    //
    // If this falls out of date for Ubuntu:
    //  Locations for both the JNI and the jar files can be located at: http://packages.ubuntu.com/
    //
    //  Search for libjhdf5-java
    //  Select the desired Ubuntu build (e.g. vivid)
    //  Click "list of files" for the appropriate architecture
    //  Find the dir for the HDF jar files (listed in dependencies) and add it to the list below
    // If you would like the location of libjhdf5.so, you can search for "libjhdf5-jni" and look at the file listing.

    flatDir {
        // Ubuntu 12.04 through 15.04.  ``sudo apt-get install hdfview``  (aside:  shared libraries are in /usr/lib/jni/)
        // May not work in versions 15.10 and above
        dirs '/usr/share/java/'
    }

    flatDir {
        // Mac following dmg install instructions in README.
        dirs '/Applications/HDFView.app/Contents/Java/'
    }

    flatDir {
        // Travis
        dirs "$System.env.HDF5_DIR/HDFView/lib/"
    }

    flatDir {
        dirs '/broad/software/free/Linux/redhat_6_x86_64/pkgs/hdfview_2.9/HDFView/lib/'
    }

    if (customJarPath) {
        flatDir {
            // Specified by user
            dirs customJarPath
        }
    }

}

jacocoTestReport {
    dependsOn test
    group = "Reporting"
    description = "Generate Jacoco coverage reports after running tests."
    additionalSourceDirs = files(sourceSets.main.allJava.srcDirs)

    reports {
        xml.enabled = true // coveralls plugin depends on xml format report
        html.enabled = true
    }
}

jacoco {
    toolVersion = "0.7.1.201405082137"
}

//NOTE: we ignore contracts for now
compileJava {
   options.compilerArgs = ['-proc:none', '-Xlint:all', '-Werror']
}

compileTestJava {
   options.compilerArgs = ['-proc:none', '-Xlint:all', '-Werror']
}

build.dependsOn installApp
check.dependsOn installApp

dependencies {
    compile files("${System.properties['java.home']}/../lib/tools.jar")
    compile 'org.apache.commons:commons-math3:3.5'
    compile 'org.broadinstitute:hellbender:4.pre-alpha-94-g7a9ca05-SNAPSHOT'
    compile 'com.opencsv:opencsv:3.4'
    compile ('org.apache.spark:spark-mllib_2.10:1.4.1') {
        // JUL is used by Google Dataflow as the backend logger, so exclude jul-to-slf4j to avoid a loop
        exclude module: 'jul-to-slf4j'
        exclude module: 'javax.servlet'
        exclude module: 'servlet-api'
    }

    // HDF5 and HDF-Java jar files
    if (isMacOsX) {
        compile name: 'jarhdf5-2.11.0'
    }
    else {
        compile name: 'jhdf5'
    }

    testCompile 'org.testng:testng:6.8.8'

    // Comment the next line to disable native code proxies in Spark MLLib
    compile('com.github.fommil.netlib:all:1.1.2')

    // Dependency change for including MLLib
    compile('org.objenesis:objenesis:1.2')
    testCompile('org.objenesis:objenesis:2.1')

    // Dependency change for including MLLib
    compile('de.javakaffee:kryo-serializers:0.26') {
        exclude module: 'kryo' // use Spark's version
    }

    // Dependency change for including MLLib
    compile('com.esotericsoftware:kryo:3.0.3'){
        exclude group: 'com.esotericsoftware', module: 'reflectasm'
        exclude group: 'org.ow2.asm', module: 'asm'
    }

    // Dependency change for including MLLib
    compile('com.esotericsoftware:reflectasm:1.10.0:shaded')
}

// Dependency change for including MLLib
configurations {
    compile.exclude module: 'jul-to-slf4j'
    compile.exclude module: 'javax.servlet'
    compile.exclude module: 'servlet-api'
    compile.exclude group: 'com.esotericsoftware.kryo'
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

def String deriveVersion(){
    def stdout = new ByteArrayOutputStream()
    try {
        logger.info("path is $System.env.PATH")
        exec {
            commandLine "git", "describe", "--always"
            standardOutput = stdout;

            ignoreExitValue = true
        }
    } catch (GradleException e) {
        logger.error("Couldn't determine version.  " + e.getMessage())
    }
    return stdout.size() > 0 ? stdout.toString().trim() : "version-unknown"
}

version = deriveVersion()
final SNAPSHOT = "-SNAPSHOT"
version = deriveVersion() + SNAPSHOT
boolean isRelease = ! version.endsWith(SNAPSHOT)
logger.info("build for version:" + version);
group = 'org.broadinstitute'


jar {
    manifest {
        attributes 'Implementation-Title': 'Hellbender-Protected-Tools',
                'Implementation-Version': version,
                'Main-Class': 'org.broadinstitute.hellbender.Main'
    }
}

// testJavaLibraryPath: Where to find jni libraries (e.g. HDF5's) to be used during testing.
// The environment variable JAVA_LIBRARY_PATH takes preference if present,
// Otherwise we used Gradle's 'testJavaLibraryPath' if present (use ~/.gradle.properties to addapt it to your dev. setup)
// or is left to the default otherwise. This default typically points to the usual system */lib directories.
def testJavaLibraryPath = System.env['JAVA_LIBRARY_PATH'] ?: hasProperty("testJavaLibraryPath") ? property("testJavaLibraryPath") : null;

test {
  
    if (testJavaLibraryPath) {
      systemProperties['java.library.path'] = testJavaLibraryPath
    }
    // enable TestNG support (default is JUnit)
    useTestNG{
        excludeGroups 'cloud', 'bucket'
    }

    // set heap size for the test JVM(s)
    minHeapSize = "1G"
    maxHeapSize = "1.5G"
    jvmArgs = ['-Xmx2G']
  
    String CI = "$System.env.CI"

    maxParallelForks = CI == "true" ? 1 : 2

    if (CI == "true") {
        int count = 0
        // listen to events in the test execution lifecycle
        testLogging {
            events "skipped", "failed"
            exceptionFormat = "full"
        }

        beforeTest { descriptor ->
            count++
            if( count % 100 == 0) {
                logger.lifecycle("Finished "+ Integer.toString(count++) + " tests")
            }
        }
    } else {
        // show standard out and standard error of the test JVM(s) on the console
        testLogging.showStandardStreams = true
        beforeTest { descriptor ->
            logger.lifecycle("Running Test: " + descriptor)
        }

        // listen to standard out and standard error of the test JVM(s)
        onOutput { descriptor, event ->
            logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message )
        }
    }
}


task wrapper(type: Wrapper) {
    gradleVersion = '2.7'
}

task fatJar(type: Jar) {
    manifest {
        attributes 'Implementation-Title': 'Hellbender',
                'Implementation-Version': version,
                'Main-Class': 'org.broadinstitute.hellbender.Main'
    }
    baseName = project.name + '-all'
    zip64 true
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar

    doLast {
        // Create a symlink to the newly created jar.  The name will be hellbender-protected-fat.jar and
        //  it will be at the same level as the newly created jar.  (overwriting symlink, if it exists)
        // Please note that this will cause failures in Windows, which does not support symlinks.
        def symlinkLocation = destinationDir.toString() + "/hellbender-protected-fat.jar"
        exec {
            commandLine 'ln', '-fs', archivePath, symlinkLocation
            ignoreExitValue = false
        }
    }
}

shadowJar {
    manifest {
        attributes 'Implementation-Title': 'Hellbender-Protected-Tools',
                'Implementation-Version': version,
                'Main-Class': 'org.broadinstitute.hellbender.Main'
    }
    baseName = project.name + '-all'
    mergeServiceFiles()
    classifier = 'spark'
    mergeServiceFiles()
    zip64 true

    // Suggested by the akka devs to make sure that we do not get the spark configuration error.
    // http://doc.akka.io/docs/akka/snapshot/general/configuration.html#When_using_JarJar__OneJar__Assembly_or_any_jar-bundler
    transform(com.github.jengelman.gradle.plugins.shadow.transformers.AppendingTransformer) {
        resource = 'reference.conf'
    }

    doLast {
        // Create a symlink to the newly created jar.  The name will be hellbender-protected.jar and
        //  it will be at the same level as the newly created jar.  (overwriting symlink, if it exists)
        // Please note that this will cause failures in Windows, which does not support symlinks.
        def symlinkLocation = destinationDir.toString() + "/hellbender-protected.jar"
        exec {
            commandLine 'ln', '-fs', archivePath, symlinkLocation
            ignoreExitValue = false
        }
    }
}

